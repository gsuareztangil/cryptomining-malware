
# This script contains the utilities to query Monero mining pools

import requests,time,json,os,csv,time,pickle
import math
from datetime import datetime
import operator
import pandas as pd
from lxml import html

dateFormat="%Y-%m-%d"
dateFormatLog="%Y-%m-%d %H:%M:%S"
FILE_STATS='../data/infoWallets/%s/info_wallets_%s.csv'%(datetime.now().strftime(dateFormat),datetime.now().strftime(dateFormat))

# Indicate if there are new wallets to be queried (e.g. from a new data feed)
NEW_WALLETS=False

exchange_addresses=[
	'46yzCCD3Mza9tRj7aqPSaxVbbePtuAeKzf8Ky2eRtcXGcEgCg1iTBio6N4sPmznfgGEUGDoBz5CLxZ2XPTyZu1yoCAG7zt6',
	'463tWEBn5XZJSxLU6uLQnQ2iY9xuNcDbjLSjkn3XAXHCbLrTTErJrBWYgHJQyrCwkNgYvyV3z8zctJLPCZy24jvb3NiTcTJ',
	'44TVPcCSHebEQp4LnapPkhb2pondb2Ed7GJJLc6TkKwtSyumUnQ6QzkCCkojZycH2MRfLcujCM7QR1gdnRULRraV4UpB5n4',
	'47sghzufGhJJDQEbScMCwVBimTuq6L5JiRixD8VeGbpjCTA12noXmi4ZyBZLc99e66NtnKff34fHsGRoyZk3ES1s1V4QVcB'
]

headers = {'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36'}

# List of pools
pools=['minexmr','nanopool','crypto-pool','ppxxmr','moneropool','monerohash','dwarfpool','supportxmr','cryptopool','bohemianpool','xmrpool','prohash','hashvault','cryptoknight','moneroocean','poolto','f2pool']

# Queries the node-cryptonote-pool based API for the stats of a given WALLET
# Returns a tuple with the following features: hashes,hashrate,lastShare,balance,paid,payments
# The payments is a dictionary whose keys are the timestamps and the values are the amounts paid
def node_cryptonote_pool_stats(walletID,statsAPI):
	url=statsAPI+'stats_address?address='+walletID
	try:
		response=requests.get(url,verify=False)
	except Exception as e:
		print ("[%s] ERROR node_cryptonote_pool_stats[%s]. Cannot make request. Exception %s"%(datetime.now().strftime(dateFormatLog),walletID,e))
		return None
	if response.status_code==200:
		try:
			stats=response.json()
			if 'stats' in stats.keys():
				if 'hashes' in stats['stats'].keys():
					hashes=stats['stats']['hashes']
				else:
					hashes='nan'
				if 'hashrate' in stats['stats'].keys():
					hashrate="%.2f"%float(str(stats['stats']['hashrate']).split()[0])
				else:
					hashrate='nan'
				if 'lastShare' in stats['stats'].keys():
					lastShare=datetime.fromtimestamp(int(stats['stats']['lastShare'])).strftime(dateFormat)
				else:
					lastShare='nan'
				if 'balance' in stats['stats'].keys():
					balance="%.10f"%(float(stats['stats']['balance'])/1000000000000)
				else:
					balance='nan'
				if 'paid' in stats['stats'].keys():
					paid="%.10f"%(float(stats['stats']['paid'])/1000000000000)
				else:
					paid='nan'
			else:
				print (("[%s] ERROR node_cryptonote_pool_stats[%s]. No stats found. Reponse:%s"%(datetime.now().strftime(dateFormatLog),walletID,response.text.replace('\n',' '))))
				return None
			#expired=stats['stats']['expired']
			payments={}
			if 'payments' in stats.keys():
				paymentList=stats['payments']
				if len(paymentList)>0:
					for i in range(0,len(paymentList),2):
						transactionHash=paymentList[i].split(':')[0]
						amount=paymentList[i].split(':')[1]
						mixin=paymentList[i].split(':')[3]
						fee=paymentList[i].split(':')[2]
						payments[int(paymentList[i+1])]=float(amount)/1000000000000
					last=int(paymentList[i+1])
					while True:
						url=statsAPI+'get_payments?time=%s&address=%s'%(last,walletID)
						response=requests.get(url,verify=False)
						if response.status_code!=200:
							break
						paymentList=response.json()
						if len(paymentList)==0:
							break
						for i in range(0,len(paymentList),2):
							transactionHash=paymentList[i].split(':')[0]
							amount=paymentList[i].split(':')[1]
							mixin=paymentList[i].split(':')[3]
							fee=paymentList[i].split(':')[2]
							payments[int(paymentList[i+1])]=float(amount)/1000000000000
						last=int(paymentList[i+1])

		except Exception as e:
			print ("[%s] ERROR node_cryptonote_pool_stats[%s]. Exception %s. Response: %s"%(datetime.now().strftime(dateFormatLog),walletID,e,response.text.replace('\n',' ')))
			return None

		return hashes,hashrate,lastShare,balance,paid,payments
	elif response.status_code==429:
		print ("[%s] ERROR node_cryptonote_pool_stats[%s]. Received %s, too many responses. (%s)"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code,response.text.replace('\n',' ')))
		return "Rate","Limit"
	else:
		print ("[%s] ERROR node_cryptonote_pool_stats[%s]. Received response: %s"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None


# Queries the minexmr API for the historical hash rate for a given wallet an days
# Returns a dictionary where keys are the timestamps (UNIX format) and the values the corresponding hashrates
def minexmr_graph(walletID,graphAPI,days=80):
	url=graphAPI+'/history_address?days=%s&address=%s'%(days,walletID)
	response=requests.get(url)
	if response.status_code==200:
		try:
			entries=response.json()
		except:
			print ("[%s] ERROR minexmr_graph[%s]. Received response: %s"%(datetime.now().strftime(dateFormatLog),walletID,response.text.replace('\n',' ')))
			return None
		graphData={}
		for entry in entries:
			timestamp=datetime.strptime(entry['rtime'],'%Y-%m-%dT%H:%M:%S.000Z')
			hashrate=entry['hr']
			graphData[time.mktime(timestamp.timetuple())]=hashrate
		return graphData
	else:
		print ("[%s] ERROR minexmr_graph [%s]. Received response: %s"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None

def nanopool_stats(walletID,statsAPI):
	# From the official documentation: "Please note that you SHOULD not make more than 30 calls per minute to the API."
	# It's not possible to get the total number of hashes

	# Check that account exits
	url=statsAPI+'accountexist/%s'%walletID
	try:
		response=requests.get(url)
	except Exception as e:
		print ("[%s] ERROR nanopool_stats [%s]. Error in requests.get. %s"%(datetime.now().strftime(dateFormatLog),walletID,e))
		return None	

	tests=1
	while response.status_code!=200 and tests<5:
		time.sleep(2)
		print ("[%s] WARNING nanopool_stats [%s]. Checking account. Received response: %s. Test %s out of 4"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code,tests))
		response=requests.get(url)
		tests+=1

	if response.status_code==200:
		if not response.json()['status']:
			print ("[%s] ERROR nanopool_stats [%s]. Account does not exist"%(datetime.now().strftime(dateFormatLog),walletID))
			return None			
	else:
		print ("[%s] ERROR nanopool_stats [%s]. Checking account. Received response: %s. Max tests"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None		
	#Balance and hashrate
	url=statsAPI+'balance_hashrate/%s'%walletID
	response=requests.get(url)
	tests=1
	while response.status_code!=200 and tests<5:
		time.sleep(2)
		print ("[%s] WARNING nanopool_stats [%s]. Getting hashrate. Received response: %s. Test %s out of 4"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code,tests))
		response=requests.get(url)
		tests+=1
	if response.status_code!=200:
		print ("[%s] ERROR nanopool_stats [%s]. Getting hashrate. Received response: %s. Max tests"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None	
	if 'data' in response.json():
		stats=response.json()
		if 'balance' in stats['data'].keys():
			balance="%.10f"%(float(stats['data']['balance']))
		else:
			balance='nan'
		if 'hashrate' in stats['data'].keys():
			hashrate="%.2f"%(float(stats['data']['hashrate']))
		else:
			hashrate='nan'
	else:
		balance='nan'
		hashrate='nan'
	# Payments and paid
	url=statsAPI+"payments/%s"%walletID
	response=requests.get(url)
	tests=1
	while response.status_code!=200 and tests<5:
		time.sleep(2)
		print ("[%s] WARNING nanopool_stats [%s]. Getting payments. Received response: %s. Test %s out of 4"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code,tests))
		response=requests.get(url)
		tests+=1
	if response.status_code!=200:
		print ("[%s] ERROR nanopool_stats [%s]. Getting payments. Received response: %s. Max tests"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None	
	payments={}
	paid=0
	if 'data' in response.json():
		stats=response.json()
		paymentList=stats['data']
		for payment in paymentList:
			transactionHash=payment['txHash']
			amount=payment['amount']
			paid+=amount
			payments[payment['date']]=float(amount)
	else:
		paid='nan'
	# Last share
	url=statsAPI+"shareratehistory/%s"%walletID
	response=requests.get(url)
	tests=1
	while response.status_code!=200 and tests<5:
		time.sleep(2)
		print ("[%s] WARNING nanopool_stats [%s]. Getting payments. Received response: %s. Test %s out of 4"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code,tests))
		response=requests.get(url)
		tests+=1
	if response.status_code!=200:
		print ("[%s] ERROR nanopool_stats [%s]. Getting payments. Received response: %s. Max tests"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None	
	stats=response.json()
	if 'data' in stats:
		shares=stats['data']
	else:
		shares=[]
	if len(shares)>0:
		lastShare=datetime.fromtimestamp(int(stats['data'][0]['date'])).strftime(dateFormat)
	else:
		lastShare='nan'
	return 'nan',hashrate,lastShare,balance,paid,payments

def nanopool_graph(walletID,graphAPI,days=0):
	url=graphAPI+'history/%s'%walletID
	response=requests.get(url)
	tests=1
	while response.status_code!=200 and tests<5:
		time.sleep(2)
		print ("[%s] WARNING nanopool_graph [%s].  Received response: %s. Test %s out of 4"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code,tests))
		response=requests.get(url)
		tests+=1
	if response.status_code!=200:
		print ("[%s] ERROR nanopool_graph [%s]. Received response: %s. Max tests"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None	
	if 'data' in response.json():
		entries=response.json()['data']
		graphData={}
		for entry in entries:
			timestamp=datetime.fromtimestamp(entry['date'])
			hashrate=entry['hashrate']
			graphData[time.mktime(timestamp.timetuple())]=hashrate
		return graphData
	else:
		print ("[%s] ERROR nanopool_graph [%s]. No data found"%(datetime.now().strftime(dateFormatLog),walletID))
		return None		

# Since the API does not provide much information, we crawl the page
def dwarfpool_stats(walletID,stats_page):
	url=stats_page+'?wallet=%s&allpayouts=1'%walletID
	response=requests.get(url,verify=False)
	if response.status_code==200:
		tree = html.fromstring(response.content)
		try:
			hashes='nan'
			balance=float(tree.xpath('//div[contains(@class,"panel-info")][1]/ul/li[1]/span/text()')[0].split()[0])
			paid=float(tree.xpath('//div[contains(@class,"panel-info")][1]/ul/li[2]/span/text()')[0].split()[0])
			lastShare=datetime.strptime(tree.xpath('//div[contains(@class,"panel-info")][2]/ul/li[2]/span/text()')[0],"%d %b %Y, %H:%M").strftime(dateFormat)
			hashrate=float(tree.xpath('//div[contains(@class,"panel-info")][2]/ul/li[3]/span/text()')[0].split()[0])		
			payouts=tree.xpath('//div[text()="Last 10 payouts"]/..//tbody/tr')
			payments={}
			for p in payouts:
				timestamp=datetime.strptime(p.xpath('./td[1]/text()')[0],"%d %b %Y, %H:%M")
				amount=float(p.xpath('./td[2]/text()')[0])
				transactionHash=p.xpath('./td[3]/span/text()')[0]
				payments[time.mktime(timestamp.timetuple())]=amount
			return hashes,hashrate,lastShare,balance,paid,payments 
		except Exception as e:
			print ("[%s] ERROR dwarfpool_stats[%s]. Exception %s. Response: %s"%(datetime.now().strftime(dateFormatLog),walletID,e,response.text.replace('\n',' ')))
			return None
	else:
		print ("[%s] ERROR dwarfpool_stats[%s]. Received response: %s"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None

def nodejs_pool_stats (walletID,statsAPI):
	url=statsAPI+'miner/%s/stats'%walletID
	try:
		response=requests.get(url,verify=False)
	except Exception as e:
		print ("[%s] ERROR nodejs_pool_stats[%s]. Cannot make request. Exception %s"%(datetime.now().strftime(dateFormatLog),walletID,e))
		return None

	if response.status_code==200:
		valid=False
		try:
			stats=response.json()
			if 'totalHashes' in stats.keys() and stats['totalHashes'] is not None:
				hashes=stats['totalHashes']
				valid=True
			else:
				hashes='nan'
			if 'hash' in stats.keys() and stats['hash'] is not None:
				hashrate="%.2f"%float(stats['hash'])
				valid=True
			else:
				hashrate='nan'
			if 'lastHash' in stats.keys() and stats['lastHash'] is not None:
				lastShare=datetime.fromtimestamp(int(stats['lastHash'])).strftime(dateFormat)
				valid=True
			else:
				lastShare='nan'				
			if 'amtDue' in stats.keys() and stats['amtDue'] is not None:
				balance="%.10f"%(float(stats['amtDue'])/1000000000000)
				valid=True
			else:
				balance='nan'
			if 'amtPaid' in stats.keys() and stats['amtPaid'] is not None:
				paid="%.10f"%(float(stats['amtPaid'])/1000000000000)
				valid=True
			else:
				paid='nan'	
		except Exception as e:
			print ("[%s] ERROR nodejs_pool_stats[%s]. Exception %s. Response: %s"%(datetime.now().strftime(dateFormatLog),walletID,e,response.text.replace('\n',' ')))
			return None
		if not valid:
			print ("[%s] ERROR nodejs_pool_stats[%s]. Address not found"%(datetime.now().strftime(dateFormatLog),walletID))
			return None
	else:
		print ("[%s] ERROR nodejs_pool_stats[%s]. Received response: %s"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None

	url=statsAPI+'miner/%s/payments'%walletID
	response=requests.get(url,verify=False)
	payments={}
	if response.status_code==200:
		try:
			paymentList=response.json()
			for payment in paymentList:
				transactionHash=payment['txnHash']
				amount=payment['amount']
				payments[payment['ts']]=float(amount)/1000000000000
		except Exception as e:
			print ("[%s] ERROR nodejs_pool_stats Payments[%s]. Exception %s. Response: %s"%(datetime.now().strftime(dateFormatLog),walletID,e,response.text.replace('\n',' ')))
			return None

	return hashes,hashrate,lastShare,balance,paid,payments

# The API only returns the hashrate for the active workers
def nodejs_pool_graph(walletID,graphAPI,days=0):
	url=graphAPI+'miner/%s/chart/hashrate/allWorkers'%walletID
	response=requests.get(url)
	if response.status_code==200:
		if 'global' in response.json():
			entries=response.json()['global']
			graphData={}
			for entry in entries:
				timestamp=entry['ts']/1000.0
				hashrate=entry['hs']
				graphData[timestamp]=hashrate
			return graphData
		else:
			print ("[%s] ERROR nodejs_pool_graph [%s]. Received empty response 200"%(datetime.now().strftime(dateFormatLog),walletID)	)
			return None
	else:
		print ("[%s] ERROR nodejs_pool_graph [%s]. Received response: %s"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None		

def f2pool_graph(walletID,graphAPI):
	url=graphAPI+walletID
	response=requests.get(url,verify=False)
	if response.status_code==200:
		stats=response.json()
		if stats['value']==0:
			print ("[%s] ERROR f2pool_stats[%s]. Address not found"%(datetime.now().strftime(dateFormatLog),walletID))
			return None
		graphData={}
		if 'hashrate_history' in stats.keys() and len(stats['hashrate_history'])>0:
			entries=stats['hashrate_history']
			
			for ts,hs in entries.items():
				timestamp=datetime.strptime(ts,"%Y-%m-%dT%H:%M:%SZ")
				graphData[time.mktime(timestamp.timetuple())]=hs
		return graphData

	else:
		print ("[%s] ERROR f2pool_graph [%s]. Received response: %s"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None		

def f2pool_stats(walletID,statsAPI):
	url=statsAPI+walletID
	response=requests.get(url,verify=False)
	if response.status_code==200:
		valid=False
		try:
			stats=response.json()
			if stats['value']==0:
				print ("[%s] ERROR f2pool_stats[%s]. Address not found"%(datetime.now().strftime(dateFormatLog),walletID))
				return None
			# F2pool does not provide the total hashes...
			hashes='nan'
			if 'hashrate' in stats.keys() and stats['hashrate']:
				hashrate="%.2f"%float(stats['hashrate'])
				valid=True
			else:
				hashrate='nan'
			if 'hashrate_history' in stats.keys() and len(stats['hashrate_history'])>0:
				lastShare='nan'
				ts=[(datetime.strptime(t,"%Y-%m-%dT%H:%M:%SZ"),v) for t,v in stats['hashrate_history'].items()]
				ts=sorted(ts,key=operator.itemgetter(0),reverse=True)
				for t,v in ts:
					if v!=0:
						lastShare=t
						if hashrate=='nan':
							hashrate=v
						break;
					if lastShare!='nan':
						lastShare=lastShare.strftime(dateFormat)
				valid=True
			else:
				lastShare='nan'				
			if 'balance' in stats.keys() and stats['balance']:
				balance="%.10f"%(float(stats['balance']))
				valid=True
			else:
				balance='nan'
			if 'paid' in stats.keys() and stats['paid']:
				paid="%.10f"%(float(stats['paid']))
				valid=True
			else:
				paid='nan'	
			payments={}
			if 'payout_history' in stats:
				paymentList=stats['payout_history']
				for payment in paymentList:
					transactionHash=payment[1]
					amount=payment[2]
					timestamp=datetime.strptime(payment[0],"%Y-%m-%dT%H:%M:%SZ")
					payments[time.mktime(timestamp.timetuple())]=float(amount)
		except Exception as e:
			print ("[%s] ERROR f2pool_stats[%s]. Exception %s. Response: %s"%(datetime.now().strftime(dateFormatLog),walletID,e,response.text.replace('\n',' ')))
			return None
		if not valid:
			print ("[%s] ERROR f2pool_stats[%s]. Address not found"%(datetime.now().strftime(dateFormatLog),walletID))
			return None
	else:
		print ("[%s] ERROR f2pool_stats[%s]. Received response: %s"%(datetime.now().strftime(dateFormatLog),walletID,response.status_code))
		return None

	return hashes,hashrate,lastShare,balance,paid,payments	

# CREATES A NEW INFO_WALLETS FILE WITH THE NEW DATA COLLECTED
def write_csv_stats(wallet,pool,n,total,day=None):
	global FILE_STATS
	if not day:
		day=datetime.now().strftime(dateFormat)
	else:
		FILE_STATS='../data/infoWallets/%s/info_wallets_%s.csv'%(day,day)
	OUTPUT_DIR_GRAPHS='../data/infoWallets/%s/pg_%s/'%(day,pool)
	if not os.path.exists(OUTPUT_DIR_GRAPHS):
		os.makedirs(OUTPUT_DIR_GRAPHS)
	try:
		wallet.decode('utf-8')
	except:
		print ("[%s] INFO Pool [%s] Wallet [%s] (%s/%s). Wrong encoding"%(datetime.now().strftime(dateFormatLog),pool,wallet,n,total))
		return 
	fd=open(FILE_STATS,'ab+')
	fd.seek(0, os.SEEK_SET)
	lines=fd.readlines()
	if len(lines)==0:
		fd.write("POOL,USER,HASHES,HASHRATE,LAST_SHARE,BALANCE,TOTAL_PAID,NUM_PAYMENTS,DATE_QUERY\n")
	else:
		# Check if the wallet and pool are already in the file. If so, returns
		for l in lines:
			if wallet in l and pool in l:
				print ("[%s] INFO Pool [%s] Wallet [%s] (%s/%s). Already present"%(datetime.now().strftime(dateFormatLog),pool,wallet,n,total))
				fd.close()
				return
	print ("[%s] INFO Pool [%s] Wallet [%s] (%s/%s). Querying"%(datetime.now().strftime(dateFormatLog),pool,wallet,n,total))
	stats=pool_functions[pool][0](wallet,api_URLs[pool][0])
	if stats:
		if len(stats)==2:
			time.sleep(5)
			write_csv_stats(wallet,pool,n,total)
		else:
			hashes,hashrate,lastShare,balance,paid,payments=stats
			fd.write("%s,%s,%s,%s,%s,%s,%s,%s,%s\n"%(pool,wallet,hashes,hashrate,lastShare,balance,paid,len(payments),datetime.now().strftime(dateFormatLog)))
			fd.close()
			if len(payments)>0:
				pickle.dump(payments,open(OUTPUT_DIR_GRAPHS+wallet+'_payments.pickle','wb+'))
			# If the pool provides graph history
			if api_URLs[pool][1] is not None:
				graph=pool_functions[pool][1](wallet,api_URLs[pool][1])
				if graph:
					pickle.dump(graph,open(OUTPUT_DIR_GRAPHS+wallet+'_graph.pickle','wb+'))
				else:
					print ("[%s] WARNING. Pool:%s Graph of wallet %s not saved"%(datetime.now().strftime(dateFormatLog),pool,wallet))
			time.sleep(0.3)

	else:
		fd.write("%s,%s,nodata,nodata,nodata,nodata,nodata,nodata,%s\n"%(pool,wallet,datetime.now().strftime(dateFormatLog)))
	

# Queries the given wallet in all the pools
def testWalletAgainstAll(wallet):
	validPools={}
	totalPaid=0.0
	for pool in api_URLs.keys():
		print ("POOL: %s \t WALLET:%s"%(pool,wallet))
		stats=pool_functions[pool][0](wallet,api_URLs[pool][0])
		if stats:
			hashes,hashrate,lastShare,balance,paid,payments=stats
			print ("Num Hashes: %s"%hashes)
			print ("HashRate: %s H/s"%hashrate)
			print ("Last share: %s"%lastShare)
			print ("Balance: %s"%(balance))
			print ("Total Paid: %s"%(paid))
			print ("NumPayments: %s"%len(payments))
			# for t,a in payments.items():
			# 	print "\t%s -> %.5f"%(datetime.fromtimestamp(t).strftime(dateFormat),a)
			try:
				if not math.isnan(float(paid)):
					totalPaid+=float(paid)
					validPools[pool]=float(paid)
			except:
				validPools[pool]=0
			
		else:
			print ("NOT FOUND")
		print ('----------------------------------\n')

	print ("Total paid:%s"%totalPaid)
	print ("Pools:%s"%len(validPools))
	for p,a in validPools.items():
		print ("\t%s (%s XMR)"%(p,a))


# Obtain the graphs and payments for the wallets using minexmr
def hash_rate_history_minexmr(day=None):
	if not day:
		day=datetime.now().strftime(dateFormat)
	OUTPUT_DIR='../data/infoWallets/%s/pg_minexmr/'%day
	if not os.path.exists(OUTPUT_DIR):
		os.makedirs(OUTPUT_DIR)
	info_wallets=pd.read_csv(FILE_STATS,keep_default_na=False,na_values=['nan','nodata','NaN'])
	info_wallets_withData=info_wallets.dropna(subset=['HASHES','HASHRATE','LAST_SHARE','BALANCE','TOTAL_PAID','NUM_PAYMENTS'], how='all')
	wallets=list(set(info_wallets_withData[info_wallets_withData['POOL']=='minexmr']['USER']))
	allGraphs={}
	for i,w in enumerate(wallets):
		if not os.path.exists(OUTPUT_DIR+w+'_graph.pickle'):
			if i>0 and (i+1)%20==0:
				print ("[%s] INFO. Processing wallet %s out of %s"%(datetime.now().strftime(dateFormatLog),(i+1),len(wallets)))
			stats=node_cryptonote_pool_stats(w,'https://p5.minexmr.com/')
			days=159
			if stats:
				hashes,hashrate,lastShare,balance,paid,payments=stats
				if len(payments)>0:
					sorted_payments=sorted(payments.items(),key=operator.itemgetter(0),reverse=False)
					first_payment=datetime.fromtimestamp(sorted_payments[0][0])
					pickle.dump(payments,open(OUTPUT_DIR+w+'_payments.pickle','wb+'))
					# Get history from one month before the first payment
					days=(datetime.now()-first_payment).days+30
					# For some reason, the API returns all NULLS when asking for 160 or more days
					if days>100:
						days=100

				graph=minexmr_graph(w,'https://s3.minexmr.com/graph/',days)
				if graph:
					pickle.dump(graph,open(OUTPUT_DIR+w+'_graph.pickle','wb+'))
				else:
					print ("[%s] WARNING. Graph of wallet %s not saved"%(datetime.now().strftime(dateFormatLog),w))
			
		else:
			graph=pickle.load(open(OUTPUT_DIR+w+'_graph.pickle'))
		allGraphs[w]=graph
	return allGraphs


def hash_rate_history(poolName,day=None):
	if not day:
		day=datetime.now().strftime('%Y%m%d')
	OUTPUT_DIR='../data/infoWallets/%s/pg_%s/'%(poolName,day,poolName)
	if not os.path.exists(OUTPUT_DIR):
		os.makedirs(OUTPUT_DIR)
	info_wallets=pd.read_csv(FILE_STATS,keep_default_na=False,na_values=['nan','nodata','NaN'])
	info_wallets_withData=info_wallets.dropna(subset=['HASHES','HASHRATE','LAST_SHARE','BALANCE','TOTAL_PAID','NUM_PAYMENTS'], how='all')
	wallets=list(set(info_wallets_withData[info_wallets_withData['POOL']==poolName]['USER']))
	allGraphs={}
	for i,w in enumerate(wallets):
		if not os.path.exists(OUTPUT_DIR+w+'_graph.pickle'):
			if i>0 and (i+1)%20==0:
				print ("[%s] INFO. Pool: %s. Processing wallet %s out of %s"%(datetime.now().strftime(dateFormatLog),poolName,(i+1),len(wallets)))
			stats=pool_functions[poolName][0](w,api_URLs[poolName][0])
			# stats=node_cryptonote_pool_stats(w,'https://p5.minexmr.com/')
			days=159
			if stats:
				hashes,hashrate,lastShare,balance,paid,payments=stats
				if len(payments)>0:
					sorted_payments=sorted(payments.items(),key=operator.itemgetter(0),reverse=False)
					first_payment=datetime.fromtimestamp(sorted_payments[0][0])
					pickle.dump(payments,open(OUTPUT_DIR+w+'_payments.pickle','wb+'))
					# Get history from one month before the first payment
					days=(datetime.now()-first_payment).days+30
					# For some reason, the API returns all NULLS when asking for 160 or more days
					if days>100:
						days=100
					if poolName=='minexmr':
						graph=pool_functions[poolName][1](w,api_URLs[poolName][1],days)
					else:
						graph=pool_functions[poolName][1](w,api_URLs[poolName][1])
				# graph=minexmr_graph(w,'https://s3.minexmr.com/graph/',days)
				if graph:
					pickle.dump(graph,open(OUTPUT_DIR+w+'_graph.pickle','wb+'))
				else:
					print ("[%s] WARNING. Pool: %s, Graph of wallet %s not saved"%(datetime.now().strftime(dateFormatLog),pool, w))
			
		else:
			graph=pickle.load(open(OUTPUT_DIR+w+'_graph.pickle'))
		allGraphs[w]=graph
	return allGraphs


if __name__ == "__main__" :


	api_URLs={
		'minexmr':('https://p5.minexmr.com/','https://s3.minexmr.com/graph/'),
		'nanopool':('https://api.nanopool.org/v1/xmr/','https://api.nanopool.org/v1/xmr/'),
		'moneropool':('https://api.moneropool.com/api/','https://api.moneropool.com/api/'),
		'supportxmr':('https://www.supportxmr.com/api/','https://www.supportxmr.com/api/'),
		'cryptopool':('https://xmr.cryptopool.space/api/','https://xmr.cryptopool.space/api/'),
		'hashvault':('https://monero.hashvault.pro/api/','https://monero.hashvault.pro/api/'),
		#'viaxmr':('https://api.viaxmr.com/','https://api.viaxmr.com/'),
		'moriaxmr':('https://api.moriaxmr.com/','https://api.moriaxmr.com/'),
		'moneroocean':('https://api.moneroocean.stream/','https://api.moneroocean.stream/'),
		'f2pool':('http://api.f2pool.com/xmr/','http://api.f2pool.com/xmr/'),
		'monerohash':('https://monerohash.com/api/',None),
		'dwarfpool':('http://dwarfpool.com/xmr/address',None),
		'crypto-pool':('https://monero.crypto-pool.fr:8091/',None),
		'ppxxmr':('https://api-xmr.yspool.com/',None),
		'bohemianpool':('https://bohemianpool.com/api/',None),
		'xmrpool':('https://web.xmrpool.eu:8119/',None),
		#'prohash':('http://xmr.prohash.net:8117/',None),
		'poolto':('https://xmr.poolto.be:8120/',None),
		'cryptoknight':('https://cryptoknight.cc/rpc/xmr/',None)
		#'minercircle':('https://xmr.minercircle.com:8079/',None),
		#'freebuf':('https://p5.minexmr.com/','https://s3.minexmr.com/graph/'),
		#'minergate':(None,None)
		
	}
	pool_functions={
		'minexmr':(node_cryptonote_pool_stats,minexmr_graph),
		'nanopool':(nanopool_stats,nanopool_graph),
		'crypto-pool':(node_cryptonote_pool_stats,None),
		'ppxxmr':(node_cryptonote_pool_stats,None),
		'moneropool':(nodejs_pool_stats,nodejs_pool_graph),
		'monerohash':(node_cryptonote_pool_stats,None),
		'dwarfpool':(dwarfpool_stats,None),
		'supportxmr':(nodejs_pool_stats,nodejs_pool_graph),
		'cryptopool':(nodejs_pool_stats,nodejs_pool_graph),
		'bohemianpool':(nodejs_pool_stats,nodejs_pool_graph),
		'xmrpool':(node_cryptonote_pool_stats,None),
		#'prohash':(node_cryptonote_pool_stats,None),
		'hashvault':(nodejs_pool_stats,nodejs_pool_stats),
		#'viaxmr':(nodejs_pool_stats,nodejs_pool_stats),
		'moriaxmr':(nodejs_pool_stats,nodejs_pool_stats),
		'moneroocean':(nodejs_pool_stats,nodejs_pool_stats),
		'poolto':(node_cryptonote_pool_stats,None),
		'f2pool':(f2pool_stats,f2pool_graph),
		'cryptoknight':(node_cryptonote_pool_stats,None)
		#'minercircle':(node_cryptonote_pool_stats,None),
		#'freebuf':(node_cryptonote_pool_stats,minexmr_graph),
		#'minergate':(None,None)
		}
	
	if NEW_WALLETS:
		# GET THE WALLETS OF PREVIOUS FILE
		filename='../data/data_from_samples_minersOLD.csv'
		lines=pd.read_csv(filename,keep_default_na=False,na_values=['None','nan'])
		walletsOld=[]
		for w in list(lines['USER']):
			for wallet in str(w).split(','):
				# These filters are to focus only in Monero addresses.
				if len(str(wallet))>90 and str(wallet)[0]=='4':
					if wallet.split('.')[0] in exchange_addresses and len(wallet.split('.'))>1:
						walletsOld.append(".".join(wallet.split('.')[:2]).split('+')[0].split('/')[0].split(":")[0].split('@')[0])	
					else:
						walletsOld.append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0].split('@')[0])
		walletsOld=list(set(walletsOld))

		# GET THE WALLETS OF NEW FILE
		filename='../data/data_from_samples_miners.csv'
		lines=pd.read_csv(filename,keep_default_na=False,na_values=['None','nan'])
		wallets=[]
		for w in list(lines['USER']):
			for wallet in str(w).split(','):
				# These filters are to focus only in Monero addresses.
				if len(str(wallet))>90 and str(wallet)[0]=='4':
					if wallet.split('.')[0] in exchange_addresses and len(wallet.split('.'))>1:
						wallets.append(".".join(wallet.split('.')[:2]).split('+')[0].split('/')[0].split(":")[0].split('@')[0])	
					else:
						wallets.append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0].split('@')[0])
		wallets=list(set(wallets))
		# GET THE NEW WALLETS FROM PREVIOUS FILE NOT IN OLD FILE
		newWallets=[f for f in wallets if not f in walletsOld]


	# QUERY ONLY FOR THOSE WALLETS FOR WHICH WE ALREADY HAVE DATA IN EACH POOL
	PREVIOUS_INFO_FILE='../data/infoWallets/info_wallets.csv'
	info_wallets = pd.read_csv(PREVIOUS_INFO_FILE,keep_default_na=False,na_values=['nan','nodata','NaN'])
	info_wallets_withData=info_wallets.dropna(subset=['HASHES','HASHRATE','LAST_SHARE'], how='all')
	for pool in pool_functions.keys():
			# Get the wallets for this pool
			wallets=list(info_wallets_withData.loc[info_wallets_withData['POOL']==pool]['USER'])
			if NEW_WALLETS:
				# Add the new wallets
				wallets.extend(newWallets)
			for n,wallet in enumerate(wallets):
				if not wallet in exchange_addresses:
					write_csv_stats(wallet,pool,n+1,len(wallets),day='2019-10-30')
	exit()




			
