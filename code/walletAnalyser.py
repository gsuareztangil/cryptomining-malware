
from bisect import *
import re
import socket,operator
from collections import defaultdict
import numpy as np
import matplotlib.pyplot as plt
import os, sys, csv, json,pickle,operator,math,time,requests
import pandas as pd
from datetime import timedelta,datetime
from sklearn import preprocessing
from subprocess import Popen, PIPE
import locale
locale.setlocale(locale.LC_ALL,"")

banned_wallets={}
lines=open('../data/info_minexmr/suspended_wallets.csv').readlines()
for l in lines[1:]:
	wallet,last_connection,total_paid=tuple(l.strip().split(','))
	banned_wallets[wallet]={'last_connection':last_connection,'total_paid':total_paid}

newly_banned={}
lines=open('../data/info_minexmr/newly_banned_accounts.csv').readlines()
for l in lines[1:]:
	wallet,totalConnections=tuple(l.strip().split(','))
	newly_banned[wallet]=totalConnections	

donation_addresses=[
'43NoJVEXo21hGZ6tDG6Z3g4qimiGdJPE6GRxAmiWwm26gwr62Lqo7zRiCJFSBmbkwTGNuuES9ES5TgaVHceuYc4Y75txCTU',
'42uasNqYPnSaG3TwRtTeVbQ4aRY3n9jY6VXX3mfgerWt4ohDQLVaBPv3cYGKDXasTUVuLvhxetcuS16ynt85czQ48mbSrWX',
'4BEX1gceBy2VVbGfqry6zeSrKXnp4kEVRhtExdTM4HrdHPXUmkPkSXm5MeBDMFLVQkXXBfUbsj7hUSjG4hVzqUpcUCw74T2',
'48edfHu7V9Z84YzzMa6fUueoELZ9ZRXq9VetWzYGzKt52XU5xvqgzYnDK9URnRoJMk1j8nLwEVsaSWJ4fhdUyZijBGUicoD',
'4581HhZkQHgZrZjKeCfCJxZff9E3xCgHGF25zABZz7oR71TnbbgiS7sK9jveE6Dx6uMs2LwszDuvQJgRZQotdpHt1fTdDhk',
'45tcqnJMgd3VqeTznNotiNj4G9PQoK67TGRiHyj6EYSZ31NUbAfs9XdiU5squmZb717iHJLxZv3KfEw8jCYGL5wa19yrVCn',
'449TGay4WWJPwsXrWZfkMoPtDbJp8xoSzFuyjRt3iaM4bRHdzw4qoDu26FdcGx67BMDS1r2bnp7f5hF6xdPWWrD3Q3Wf7G6',
'47mr7jYTroxQMwdKoPQuJoc9Vs9S9qCUAL6Ek4qyNFWJdqgBZRn4RYY2QjQfqEMJZVWPscupSgaqmUn1dpdUTC4fQsu3yjN',
'44AFFq5kSiGBoZ4NMDwYtN18obc8AemS33DBLWs3H7otXft3XjrpDtQGv7SqSsaBYBb98uNbr2VBBEt7f2wfn3RVGQBEP3A',
'44Ldv5GQQhP7K7t3ZBdZjkPA7Kg7dhHwk3ZM3RJqxxrecENSFx27Vq14NAMAd2HBvwEPUVVvydPRLcC69JCZDHLT2X5a4gr',
'43SLUTpyTgXCNXsL43uD8FWZ5wLAdX7Ak67BgGp7dxnGhLmrffDTXoeGm2GBRm8JjigN9PTg2gnShQn5gkgE1JGWJr4gsEU',
'42QWoLF7pdwMcTXDviJvNkWEHJ4TXnMBh2Cx6HNkVAW57E48Zfw6wLwDUYFDYJAqY7PLJUTz9cHWB5C4wUA7UJPu5wPf4sZ',
'46gq64YYgCk88LxAadXbKLeQtCJtsLSD63NiEc3XHLz8NyPAyobACP161JbgyH2SgTau3aPUsFAYyK2RX4dHQoaN1ats6iT',
'43hY5fJXKmZTeDxnHCZ4h8Y6ELL7fcAzeUJnD6Zj5FZX5veiCdJijyyVbNVceRDXrk547n6DVfyQoVjSGBmfk47SJ6mxaWY'
]
exchange_addresses=[
	'46yzCCD3Mza9tRj7aqPSaxVbbePtuAeKzf8Ky2eRtcXGcEgCg1iTBio6N4sPmznfgGEUGDoBz5CLxZ2XPTyZu1yoCAG7zt6',
	'463tWEBn5XZJSxLU6uLQnQ2iY9xuNcDbjLSjkn3XAXHCbLrTTErJrBWYgHJQyrCwkNgYvyV3z8zctJLPCZy24jvb3NiTcTJ',
	'44TVPcCSHebEQp4LnapPkhb2pondb2Ed7GJJLc6TkKwtSyumUnQ6QzkCCkojZycH2MRfLcujCM7QR1gdnRULRraV4UpB5n4',
	'47sghzufGhJJDQEbScMCwVBimTuq6L5JiRixD8VeGbpjCTA12noXmi4ZyBZLc99e66NtnKff34fHsGRoyZk3ES1s1V4QVcB'
]

INFO_FILE='../data/info_wallets_with_usd.csv'
info_wallets = pd.read_csv(INFO_FILE,keep_default_na=False,na_values=['nan','nodata','NaN'])
info_wallets=info_wallets[~info_wallets['USER'].isin(donation_addresses)]
info_wallets=info_wallets[~info_wallets['USER'].isin(exchange_addresses)]
info_wallets_withData=info_wallets.dropna(subset=['HASHES','HASHRATE','LAST_SHARE','BALANCE','TOTAL_PAID','NUM_PAYMENTS'], how='all')


filename_data_from_samples='../data/miners_dataset.csv'
data_from_samples=pd.read_csv(filename_data_from_samples,keep_default_na=False,na_values=['None','nan'])
data_from_samples_with_users=data_from_samples[data_from_samples['USER'].notnull()]
samples=list(data_from_samples_with_users['SHA256'])

BTC_USD_EXCHANGE=6746

'''
 NOTE that the dataset.json file is not provided since it contains info protected by a NDA. 
 See virusTotalAnalyser.py for instructionson how to create your own version of this file
'''
try:
	dataset=json.load(open('../data/dataset.json'))
except:
	dataset={}






def get_Monero_campaigns():
	currency_campaigns=pickle.load(open('../data/currency_campaigns.pickle'))
	monero_campaigns=[]
	for c in currency_campaigns:
		if 'MONERO' in currency_campaigns[c]:
			monero_campaigns.append(c)
	return monero_campaigns


def is_donation_wallet(wallet):
	for w1 in donation_addresses:
		if w1 in wallet:
			return True
	return False
def is_exchange_wallet(wallet):
	for w1 in exchange_addresses:
		if w1 in wallet:
			return True
	return False


linesMalware=open('../data/not_malware_samples.csv').readlines()
def is_not_malware(sample):
	for l in linesMalware:
		if 'REMOVE' in l and sample in l:
			return True
	return False	





# Returns true if the domain is of a known pool, False otherwise
def knownPool(domain):
	knownPools=['minexmr','nanopool','crypto-pool','ppxxmr','minercircle','xmrpool','monerohash','moneropool','supportxmr','cryptopool','dwarfpool','prohash','bohemianpool','hashvault','viaxmr','moriaxmr','moneroocean','minergate']
	for p in knownPools:
		if p in domain:
			return True
	return False

def check_samples_with_no_detections(outfile='../data/not_malware_samples.csv'):
	dataset=json.load(open('../data/dataset.json'))
	data_from_samples_with_users=data_from_samples[data_from_samples['USER'].notnull()]
	samples=list(data_from_samples_with_users['SHA256'])
	numSamplesToRemove=0
	numSamplesWithRelated=0
	fd=open(outfile,'w')
	for sample in samples:
		if sample in dataset and 'positives' in dataset[sample]:
			if dataset[sample]['positives']<10:
				related=False
				wallets=str(list(data_from_samples[data_from_samples.SHA256==sample]['USER'])[0]).split(',')
				#print sample,len(wallets)
				related_samples=[]
				for w in wallets:
					if len(str(w))>90 and str(w)[0]=='4':
						if w.split('.')[0] in exchange_addresses and len(w.split('.'))>1:
							w=".".join(w.split('.')[:2]).split('+')[0].split('/')[0].split(":")[0].split('@')[0]
						else:
							w=w.split('.')[0].split('+')[0].split('/')[0].split(":")[0].split('@')[0]
					try:
						related_samples.extend(data_from_samples[data_from_samples.USER.notnull() & data_from_samples.USER.str.contains(w,regex=False)]['SHA256'])
					except:
						pass
				for rsample in related_samples:
					if rsample in dataset and 'positives' in dataset[rsample] and dataset[rsample]['positives']>=10:
						related=True
						break
				if not related:
					numSamplesToRemove+=1
					fd.write("REMOVE,%s\n"%sample)
				else:
					numSamplesWithRelated+=1
					fd.write("RELATED,%s\n"%sample)
	fd.close()

# Print top N wallets according to the total monero obtained
def print_top_paid_bitcoin(n=50,latexFormat=False,snapshot='2018-08-26'):
	bitcoin_info_file='../data/infoWallets/bitcoin/nicehash%s/info_wallets_%s.csv'%(snapshot,snapshot)
	info_wallets_bitcoin = pd.read_csv(bitcoin_info_file,keep_default_na=False,na_values=['nan','nodata','NaN'])
	pd.set_option('display.float_format', lambda x: "{:,.3f}".format(x))
	wallets_with_paid= info_wallets_bitcoin[info_wallets_bitcoin['TOTAL_PAID'].notnull()]
	dataFrame=pd.DataFrame(wallets_with_paid.groupby(['USER'])['TOTAL_PAID'].agg('sum'))
	dataFrame['USD']=dataFrame['TOTAL_PAID']*BTC_USD_EXCHANGE
	if latexFormat:
		print dataFrame.sort_values(by=['TOTAL_PAID'],ascending=False).head(n=n).to_latex()
	else:
		print dataFrame.sort_values(by=['TOTAL_PAID'],ascending=False).head(n=n)

	print "Total Wallets:",len(dataFrame),"Total Paid: {:,.2f}".format(wallets_with_paid['TOTAL_PAID'].sum()),"USD Equivalent: {:,.2f}".format(wallets_with_paid['TOTAL_PAID'].sum()*BTC_USD_EXCHANGE)

def count_if(series):
	total=0
	for index,wallet in series.iteritems():
		if wallet in exchange_addresses or wallet in donation_addresses:
			continue
		total+=1
	return total

# Print top N wallets according to the total monero obtained
def print_top_paid(n=10,latexFormat=False,withUSD=True):
	pd.set_option('display.float_format', lambda x: "{:,.0f}".format(x))
	wallets_with_paid= info_wallets[info_wallets['TOTAL_PAID'].notnull()]
	if withUSD:
		dataFrame=pd.DataFrame(wallets_with_paid.groupby(['USER'])['TOTAL_PAID','USD'].agg('sum'))
	else:
		dataFrame=pd.DataFrame(wallets_with_paid.groupby(['USER'])['TOTAL_PAID'].agg('sum'))

	if latexFormat:
		print dataFrame.sort_values(by=['TOTAL_PAID'],ascending=False).head(n=n).to_latex()
	else:
		 print (dataFrame.sort_values(by=['TOTAL_PAID'],ascending=False).head(n=n))
	if withUSD:
		print "Total Wallets:",len(set(list(info_wallets_withData['USER']))),"Total Paid: {:,.2f}".format(dataFrame['TOTAL_PAID'].sum()),"USD Equivalent: {:,.2f}".format(dataFrame['USD'].sum())
	else:
		print "Total Wallets:",len(set(list(info_wallets_withData['USER']))),"Total Paid: {:,.2f}".format(dataFrame['TOTAL_PAID'].sum())

def print_top_hashrate(n=50):
	wallets_with_paid= info_wallets[info_wallets['HASHRATE'].notnull()]
	print pd.DataFrame(wallets_with_paid.groupby(['USER'])['HASHRATE'].agg('sum')).sort_values(by=['HASHRATE'],ascending=False).head(n=n)	
	print len(list(set(wallets_with_paid['USER'])))


def get_top_wallets_by_num_pools(N=50):
	counted=info_wallets_withData['USER'].value_counts()
	printed=0
	for wallet,times in counted.iteritems():
		print "%s,%s,"%(wallet,times),
		domains=info_wallets_withData[info_wallets_withData['USER']==wallet]['POOL']
		for i,pool in domains.iteritems():
			print "%s,"%pool,
		print
		printed+=1
		if printed>N:
			break

def resolveIP(ip):
	hostname='NOT-FOUND'
	try:
		result =  requests.get("https://www.threatcrowd.org/searchApi/v2/ip/report/", params = {"ip": ip})
		j = json.loads(result.text)
		if 'resolutions' in j and len(j['resolutions'])>0:
			isKnownPool=False
			for r in j['resolutions']:
				if knownPool(r["domain"]):
					hostname=r["domain"]
					isKnownPool=True
			if not isKnownPool:
				# If not of a known pool, get the last resolved
				hostname=j['resolutions'][-1]["domain"]
		else:
			hostname="NOT-FOUND"							
	except Exception as e:
		print e
		try:
			(hostname, aliaslist, ipaddrlist)=socket.gethostbyaddr(ip)
		except Exception as e:
			hostname="NOT-FOUND"
	return hostname

def detect_proxies(filename,resolveIPs=True,onlyMonero=True):
	if not os.path.exists(filename):
		potentialProxies=data_from_samples.loc[((data_from_samples['POOL'].isnull()) & (data_from_samples['DSTIP'].notnull())),]
		potentialProxies=potentialProxies.append(data_from_samples.loc[(data_from_samples['POOL'].notnull() & data_from_samples['POOL'].str.contains("[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}")),])
		campaigns={}

		perProxy={}
		patternIP = re.compile("[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}")

		for i,values in potentialProxies.iterrows():
			users=str(values['USER']).split(',')
			sha256=values['SHA256']
			for u in users:
				if str(u)=='nan':
					continue
				if u.split('.')[0] in exchange_addresses and len(u.split('.'))>1:					
					wallet=".".join(u.split('.')[:2]).split('+')[0].split('/')[0].split(":")[0].split('@')[0] 
				else:
					wallet=u.split('.')[0].split('+')[0].split('/')[0].split(":")[0]

				if onlyMonero and not get_currency(wallet)=='MONERO':
					continue
				ipList=[]
				if str(values['DSTIP'])!='nan':
					ipList=values['DSTIP'].split(',')
				elif str(values['POOL'])!='nan' and patternIP.match(values['POOL']):
					ipList=values['POOL'].split(',')
				for ip in ipList:
					if resolveIPs:
						hostname=resolveIP(ip)
					else:
						hostname='NOT-RESOLVED'
					if not knownPool(hostname):
						if not ip in perProxy: 
							perProxy[ip]=[]
						if not wallet in perProxy[ip]:
							perProxy[ip].append(wallet+'-'+sha256)

		ordered_data=sorted(perProxy,key=lambda x: len(perProxy[x]),reverse=True)
		for u in ordered_data:
			print "%s,%s:"%(u,len(perProxy[u]))
			isProxy=False
			hasMonero=False
			for ws in perProxy[u]:
				wallet=ws.split('-')[0]
				sha256=ws.split('-')[1]
				if wallet in list(info_wallets_withData['USER']):
					isProxy=True
				if get_currency(wallet)=='MONERO':
					hasMonero=True
				print "\t%s - %s"%(wallet,sha256)
				if isProxy: 
					name="PROXY-"+u
					print "Type: PROXY"
				elif hasMonero:
					name='PRIVATE_POOL-'+u
					print "Type: PRIVATE POOL"
				else:
					name='UNKNOWN'
					print "Type: UNKNOWN"
				if not name=='UNKNOWN':
					if not name in campaigns:
						campaigns[name]={'wallets':[wallet],'samples':[sha256]}
					else:
						if not wallet in campaigns[name]['wallets']:
							campaigns[name]['wallets'].append(wallet)
						if not sha256 in campaigns[name]['samples']:
							campaigns[name]['samples'].append(sha256)
				print
		with open(filename,'wb') as f:
			pickle.dump(campaigns,f)
	else:
		campaigns=pickle.load(open(filename))
		print "%s already exists. Remove if you want to overwrite"%filename
		ordered_data=sorted(campaigns,key=lambda x: len(campaigns[x]['wallets']),reverse=True)
		for proxy in ordered_data:
			print "%s: %s wallets, %s samples"%(proxy,len(campaigns[proxy]['wallets']),len(campaigns[proxy]['samples']))

# Prints (with CSV format) information related to the amount of pools to which wallets have mined aggregated by the total paid given in the thresholds
# Sample usage: num_pools_total_paid([0,1,100,1000,10000],perWallet=False,remove_zero=False)
def num_pools_total_paid(thresholds,perWallet=False,remove_zero=True,use_percentage=True):
	numPools={}
	maximum={}
	totalItems={}
	totalMax=0
	for t in thresholds:
		numPools[t]={}
		maximum[t]=0
		totalItems[t]=0
	num_per_threshold=[]
	if perWallet:
		wallets=[]
		campaigns=pickle.load(open('../data/aggregated_campaigns_second_round.pickle'))
		moneroCampaigns=get_Monero_campaigns()
		for c in campaigns:
			if c in moneroCampaigns:
				wallets.extend(campaigns[c]['wallets'])
		wallets=list(set(wallets))
		for wallet in wallets:
			if os.path.exists('../data/stats_wallets/%s.pickle'%wallet):
				totalPaid,numSamples,poolData=pickle.load(open('../data/stats_wallets/%s.pickle'%wallet))
			else:
				continue
			if totalPaid is None:
				continue
			if remove_zero and totalPaid==0:
				continue
			num=len(get_pools_mined(wallet))
			for i,t in enumerate(thresholds):
				option=totalPaid>=t
				if i!=len(thresholds)-1:
					option= option and totalPaid<thresholds[i+1]
				if option:
					totalItems[t]+=1
					if not num in numPools[t]:
						numPools[t][num]=1
					else:
						numPools[t][num]+=1
					maximum[t]=max(num,maximum[t])
					totalMax=max(num,totalMax)
	# PER CAMPAIGN
	else:
		campaigns=pickle.load(open('../data/aggregated_campaigns_second_round.pickle'))
		monero=get_Monero_campaigns()
		for c in monero:
			# Get the data
			wallets=campaigns[c]['wallets']
			totalPaid,totalSamples,totalWallets,poolData,totalUSDWallets=stats_wallets(wallets,numTab=0,verbose=False)   

			# Stop if this campaign have not mined any XMR and remove_zero is True
			if totalPaid is None:
				continue			
			if remove_zero and totalPaid<=0:
				continue			

			# Get the pools where the campaign has mined
			pools_mined=[]
			for w in poolData:
				for pool_data_item in poolData[w]:
					pool=pool_data_item['POOL']
					if not pool in pools_mined:
						pools_mined.append(pool)
			num=len(pools_mined)

			#print "Campaign:%s,NumPools:%s,TotalPaid:%s"%(c,num,totalPaid)
			for i,t in enumerate(thresholds):
				option=totalPaid>=t
				if i!=len(thresholds)-1:
					option = option and totalPaid<thresholds[i+1]
				if option:
					totalItems[t]+=1
					if not num in numPools[t]:
						numPools[t][num]=1
					else:
						numPools[t][num]+=1
					maximum[t]=max(num,maximum[t])
					totalMax=max(num,totalMax)
					# if t==thresholds[-1]:
					# 	print c,t,num,','.join(pools_mined)
	for thre in numPools:
		for num in numPools[thre]:
			print thre, num, numPools[thre][num]
	# exit()
	#print "NUM_POOLS,",
	if remove_zero:
		print "(0-%s) (%s),"%(thresholds[1],totalItems[thresholds[0]]),
	else:
		print "<%s (%s),"%(thresholds[1],totalItems[thresholds[0]]),
	for i in range(1,len(thresholds)-1):
		print "[%s-%s) (%s),"%(thresholds[i],thresholds[i+1],totalItems[thresholds[i]]),
	print ">=%s (%s)"%(thresholds[-1],totalItems[thresholds[-1]])
	for num in range(1,totalMax+1):
		#print "%s,"%i,
		for t in thresholds[:-1]:
			if num in numPools[t]:
				# print "%s,%s,%.2f"%(i,numPools[t][i],(100.0*numPools[t][i]/totalItems[t]))
				if use_percentage:
					print "%.2f,"%(100.0*numPools[t][num]/totalItems[t]),
				else:
					print "%d,"%(numPools[t][num]),
			else:
				print "0,",
		t=thresholds[-1]
		if num in numPools[t]:
			# print "%s,%s,%.2f"%(i,numPools[t][i],(100.0*numPools[t][i]/totalItems[t]))
			if use_percentage:
				print "%.2f"%(100.0*numPools[t][num]/totalItems[t])
			else:
				print "%d"%(numPools[t][num])
		else:
			print "0"


def get_pools_mined(wallet,onlyKnownPools=True):
	pools=[]
	domains=info_wallets_withData[info_wallets_withData['USER']==wallet]['POOL']
	for i,pool in domains.iteritems():
		if onlyKnownPools and knownPool(pool):
			pools.append(pool)
		elif not onlyKnownPools:
			pools.append(pool)
	return list(set(pools))

# Returns the time series (pandas Dataframe) from the graph of the given wallet
def getGraphWallet(wallet,directory,remove_pre_nulls=False,remove_post_nulls=False):
	filename=directory+wallet+'_graph.pickle'
	if not os.path.exists(filename):
		print "Graph of wallet %s not found"%wallet
		return None
	try:
		graph=pickle.load(open(filename))
	except:
		print "Cannot load pickle of %s"%filename
		return None
	graph_with_values=[(timestamp,value) for timestamp,value in graph.items() if value and value>0]
	if len(graph_with_values)==0:
		print "Graph of wallet %s has no values (dir=%s)"%(wallet,directory)
		return None

	sorted_graph_values=sorted(graph_with_values,key=operator.itemgetter(0))

	# Sort all the graph
	sorted_graph_all=sorted(graph.items(),key=operator.itemgetter(0))
	# Get all the values since the first non-null was seen 
	sorted_graph=[]

	# Variabl i holds the first non-null value
	i=0
	while i<len(sorted_graph_all) and sorted_graph_all[i][0]<sorted_graph_values[0][0]: i+=1

	# Variabl j holds the last non-null value
	j=len(sorted_graph_all)-1
	while j>0 and sorted_graph_all[j][0]>sorted_graph_values[-1][0]: j-=1
	
	# Check parameters to set out limits
	if not remove_post_nulls: j=len(sorted_graph_all)-1
	if not remove_pre_nulls: i=0
	
	while i<=j:
		sorted_graph.append(sorted_graph_all[i])
		i+=1

	
	dataframe_graph=pd.DataFrame(sorted_graph)
	dataframe_graph.columns = ['DATE', 'HASHRATE']
	dataframe_graph['DATE']=pd.to_datetime(dataframe_graph['DATE'],unit="s")
	# Get rid of erroneus measurement by minexmr
	mask=(dataframe_graph.DATE < datetime.strptime('2018-06-29 07:30','%Y-%m-%d %H:%M')) | (dataframe_graph.DATE > datetime.strptime('2018-06-29 11:30','%Y-%m-%d %H:%M'))
	dataframe_graph=dataframe_graph.loc[mask]
	mask=(dataframe_graph.DATE < datetime.strptime('2018-05-27 18:15','%Y-%m-%d %H:%M')) | (dataframe_graph.DATE > datetime.strptime('2018-05-27 20:45','%Y-%m-%d %H:%M'))
	dataframe_graph=dataframe_graph.loc[mask]


	return dataframe_graph

def aggregate_hash_rate(wallets,startDate=None,endDate=None,remove_pre_nulls=False,remove_post_nulls=False,verbose=False):
	aggregatedHashRate={}
	numGraphs=0
	for wallet in wallets:
		pools=info_wallets_withData.loc[info_wallets_withData['USER']==wallet][['POOL','TOTAL_PAID']]
		if verbose: print "STATS OF %s"%wallet
		for i,values in pools.iterrows():
			pool=values['POOL']
			totalPaid=values['TOTAL_PAID']
			if verbose: print "Pool:%s, Total Paid=%s"%(pool,totalPaid)		
			directory='../data/infoWallets/merged/%s/'%pool
			filename=directory+wallet+'_graph.pickle'	
			if not os.path.exists(filename):
				print "GRAPH OF %s in %s does not exist"%(wallet,pool)
				continue
			graph=getGraphWallet(wallet,directory,remove_pre_nulls=remove_pre_nulls,remove_post_nulls=remove_post_nulls)
			if graph is None:
				continue
			if startDate:
				graph=graph.loc[graph.DATE>=startDate]
			if endDate:
				graph=graph.loc[graph.DATE<=endDate]	
			graph=graph.fillna(0)


			
			if verbose: print "Median: %.2f"%graph[graph['HASHRATE']>0]['HASHRATE'].median()
			if verbose: print "Mean: %.2f"%graph[graph['HASHRATE']>0]['HASHRATE'].mean()
			maximum=graph[graph['HASHRATE']>0]['HASHRATE'].max()
			minimum=graph[graph['HASHRATE']>0]['HASHRATE'].min()
			if verbose: print "Min: %.2f"%(minimum)
			if verbose: print "Max: %.2f (%s)"%(maximum,graph.loc[graph['HASHRATE']==maximum,'DATE'].iloc[0])
			print "INCLUDING GRAPH OF %s in %s"%(wallet,pool)
			numGraphs+=1
			for i,values in graph.iterrows():
				date=values['DATE']
				hashrate=int(values['HASHRATE'])
				if not date in aggregatedHashRate:
					aggregatedHashRate[date]=hashrate
				else:
					aggregatedHashRate[date]+=hashrate

	sorted_graph=sorted(aggregatedHashRate.items(),key=operator.itemgetter(0))
	dataframe=pd.DataFrame(sorted_graph)
	dataframe.columns = ['DATE', 'HASHRATE']
	mask=(dataframe.DATE < datetime.strptime('2018-04-05 00:00','%Y-%m-%d %H:%M')) | (dataframe.DATE > datetime.strptime('2018-04-06 23:59','%Y-%m-%d %H:%M'))
	dataframe=dataframe.loc[mask]
	median=dataframe[dataframe['HASHRATE']>0]['HASHRATE'].median()
	mean=dataframe[dataframe['HASHRATE']>0]['HASHRATE'].mean()
	maximum=dataframe[dataframe['HASHRATE']>0]['HASHRATE'].max()
	maximumDate=dataframe.loc[dataframe['HASHRATE']==maximum,'DATE'].iloc[0]
	minimum=dataframe[dataframe['HASHRATE']>0]['HASHRATE'].min()
	if verbose: print "AGGREGATED STATS OF %s GRAPHS"%numGraphs
	if verbose: print "Median: %.2f"%median
	if verbose: print "Mean: %.2f"%mean
	if verbose: print "Min: %.2f"%(minimum)
	if verbose: print "Max: %.2f (%s)"%(maximum,maximumDate)	
	return dataframe,numGraphs,median,mean,maximum,maximumDate,minimum

def hash_rate_stats(wallet,startDate=None,endDate=None,directory='../data/infoWallets/merged/minexmr/',remove_pre_nulls=False,remove_post_nulls=False):
	graph=getGraphWallet(wallet,directory,remove_pre_nulls=remove_pre_nulls,remove_post_nulls=remove_post_nulls)
	if graph is None:
		return
	if startDate:
		graph=graph.loc[graph.DATE>=startDate]
	if endDate:
		graph=graph.loc[graph.DATE<=endDate]

	graph=graph.fillna(0)
	maximum=graph[graph['HASHRATE']>0]['HASHRATE'].max()
	minimum=graph[graph['HASHRATE']>0]['HASHRATE'].min()

	if wallet in newly_banned:
		connections=newly_banned[wallet]
	else:
		connections='NA'
	print '%s,%2.f,%2.f,%.2f,%s,%.2f,%s,%.2f,%s,%s'%(
		wallet,
		graph[graph['HASHRATE']>0]['HASHRATE'].median(),
		graph[graph['HASHRATE']>0]['HASHRATE'].mean(),
		minimum,
		graph.loc[graph['HASHRATE']==minimum,'DATE'].iloc[0],
		maximum,
		graph.loc[graph['HASHRATE']==maximum,'DATE'].iloc[0],
		graph.tail(1)['HASHRATE'],
		graph.tail(1)['DATE'].iloc[0],
		connections
		)
def plot_graph_dataframe(graph,title):
	plt.figure()
	plt.title(title)
	plt.plot(graph.DATE,graph.HASHRATE)
	plt.ylabel('Hashrate')
	ax = plt.gca()
	ax.get_yaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x))))
	plt.show()

def plot_graphs_various_wallets(wallets,startDate=None,endDate=None,remove_pre_nulls=False,remove_post_nulls=False):
	ymax=0
	xmax=datetime(1999,1,1)
	xmin=datetime.now()
	graphs=[]
	for wallet in wallets:
		for pool in wallets[wallet].split(','):
			directory='../data/infoWallets/merged/%s/'%pool
			graph=getGraphWallet(wallet,directory,remove_pre_nulls=remove_pre_nulls,remove_post_nulls=remove_post_nulls)	
			if graph is not None:
				print "Including data from %s in pool %s"%(wallet,pool)
				graphs.append((graph,wallet,pool))
				ymax=max(ymax,graph.HASHRATE.max())
				xmin=min(xmin,graph.DATE.min())
				xmax=max(xmax,graph.DATE.max())
	numPlots=len(graphs)
	plt.figure()
	for i,(graph,wallet,pool) in enumerate(graphs):
		if startDate:
			graph=graph.loc[graph.DATE>=startDate]
		if endDate:
			graph=graph.loc[graph.DATE<=endDate]
		graph=graph.fillna(0)			
		plt.subplot(int("%s1%s"%(numPlots,(i+1))))
		plt.ylim(0,ymax)
		plt.xlim(xmin,xmax)
		plt.title(wallet+"-"+pool)
		plt.plot(graph.DATE,graph.HASHRATE)
		plt.ylabel('Hashrate')
	ax = plt.gca()
	ax.get_yaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x))))
	plt.subplots_adjust(hspace = 0.5)
	plt.show()

# Plots the graph of historical hash rates of a given wallet
def plot_graph(wallet,wallet2=None,startDate=None,endDate=None,pool='minexmr',remove_pre_nulls=False,remove_post_nulls=False):
	directory='../data/infoWallets/merged/%s/'%pool
	graph=getGraphWallet(wallet,directory,remove_pre_nulls=remove_pre_nulls,remove_post_nulls=remove_post_nulls)
	graph2=None
	if wallet2:
		graph2=getGraphWallet(wallet2,directory,remove_pre_nulls=remove_pre_nulls,remove_post_nulls=remove_post_nulls)
	if not (graph is None):
		#print graph
		if startDate:
			graph=graph.loc[graph.DATE>=startDate]
		if endDate:
			graph=graph.loc[graph.DATE<=endDate]
		graph=graph.fillna(0)
		if not (graph2 is None):
			if startDate:
				graph2=graph2.loc[graph2.DATE>=startDate]
			if endDate:
				graph2=graph2.loc[graph2.DATE<=endDate]			
			graph2=graph2.fillna(0)
			ymax=max(graph2.HASHRATE.max(),graph.HASHRATE.max())
			plt.figure()
			plt.ylim(0,ymax)
			plt.title(wallet+"\nvs\n"+wallet2)
			plt.subplot(211)
			plt.title(wallet)
			plt.plot(graph.DATE,graph.HASHRATE)
			plt.ylabel('Hashrate')
			ax = plt.gca()
			ax.get_yaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x))))
			plt.subplot(212)
			plt.title(wallet2)
			plt.ylim(0,ymax)
			plt.plot(graph2.DATE,graph2.HASHRATE)
			plt.ylabel('Hashrate')
			ax = plt.gca()
			ax.get_yaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x))))
		else:
			plt.figure()
			plt.title(wallet)
			plt.plot(graph.DATE,graph.HASHRATE)
			plt.ylabel('Hashrate')
			ax = plt.gca()
			ax.get_yaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x))))
		plt.show()
	
# Obtains a dictionary containing the pools used for mining per wallet and the different domains/ips/pools monitored in the samples, splitted by the sha256
# The dictionary (data) keys are the wallets and values are sub-dictionary. Keys of this sub-dictionaries are the SHA256 hashes of this wallet and 'mined', 
# which stores a list of pools having data for this wallet. Tha values for the SHA256 keys are tuples of 3 lists and 1 value: the pools, ips and domains observed for this sample and the firstSeen date of the sample
def monitored_vs_mined(wallets,outputFile='../data/monitored_vs_mined.pickle'):
	if not os.path.exists(outputFile):
		data={}		
		data_from_samples_with_users=data_from_samples[data_from_samples['USER'].notnull()]
		for i,wallet in enumerate(wallets):
			if (i+1)%100==0 and not i==0:
				print 'Processed %s out of %s wallets'%(i+1,len(wallets))
			sha256_list=data_from_samples_with_users[data_from_samples_with_users['USER'].str.contains(wallet)]
			if not wallet in data.keys(): 
					data[wallet]={}		
			for i,value in sha256_list.iterrows():
				sha256=value['SHA256']
				if not sha256 in data[wallet].keys():			
					ips=[]
					dns=[]
					pools=[]
					# TODO: Take the firstSeenDate from the reports
					firstSeen='N/A'
				else:
					ips,dns,pools,firstSeen=data[wallet][sha256]
				# if str(line['USER'])!='nan' and wallet in line['USER']:	
				
				dns_tmp=[]
				for item in value['DNSRR'].split(']-['):
					dns_tmp.append(item.replace('[','').replace(']',''))
				dns.extend(list(set(dns_tmp)))
				if value['DSTIP']:
					ips.append(value['DSTIP'])
				if value['POOL']:
					pools.append(value['POOL'])
				
					
				data[wallet][sha256]=(list(set(pools)),list(set(ips)),list(set(dns)),firstSeen)
					
			data[wallet]['mined']=get_pools_mined(wallet)
		pickle.dump(data,open(outputFile,'wb'))
	else:
		data=pickle.load(open(outputFile))
	return data


# Returns a dictionary whose keys are the pools and values the last shares on this pools by a given wallet
def getLastShares(wallet):
	lastShares={}
	lastSharesData= info_wallets_withData[info_wallets_withData['LAST_SHARE'].notnull()]
	lastSharesData= lastSharesData[lastSharesData['USER']==wallet][['POOL','LAST_SHARE']]
	
	for index,data in lastSharesData.iterrows():
		pool=data['POOL']
		lastShare=data['LAST_SHARE']
		lastShares[pool]=lastShare
	return lastShares

# Looks for domains that are CNAMEs of known pools (stored in the filename given as parameter) in the activity reported by each sample
def lookup_alternative_pool_domains(filename='../data/alternative_domains_pools.csv'):
	wallets=list(set(info_wallets_withData['USER']))
	#DOMAIN,IP,LAST_RESOLVED,ALTERNATIVE_DOMAIN
	lines=list(csv.reader(open(filename),quotechar='"'))
	alternative_domains=[line[3]+"_-_"+line[2] for line in lines if not knownPool(line[3])]
	data=monitored_vs_mined(wallets)
	for wallet in data:
		lastShares=getLastShares(wallet)
		mined=data[wallet]['mined']
		mined_lastShared=[]
		for m in mined:
			if m in lastShares.keys():
				mined_lastShared.append("%s(%s)"%(m,lastShares[m]))
			else:
				mined_lastShared.append("%s(N/A)"%m)
		found=False
		for sha256 in data[wallet].keys():
			if not sha256=='mined':
				pools,ips,dns,firstSeen=data[wallet][sha256]
				# Check if any of the pools monitored for this wallet is a CNAME
				for p in pools:
					for a in alternative_domains:
						if p in a.split("_-_")[0] or a.split("_-_")[0] in p:
							if firstSeen !='N/A':
								firstSeen=datetime.strptime(firstSeen.split()[0],"%m/%d/%y").strftime("%Y-%m-%d")
							print "%s,%s,%s,%s,%s,%s"%(sha256,wallet,a.split("_-_")[0],a.split("_-_")[1],firstSeen,"-".join(mined_lastShared))
							found=True
							break
					if found:
						break
				if not found:
					# Check if any of DNS resolved for this wallet is a CNAME
					for p in dns:
						for a in alternative_domains:
							if p in a.split("_-_")[0] or a.split("_-_")[0] in p:
								if firstSeen !='N/A':
									firstSeen=datetime.strptime(firstSeen.split()[0],"%m/%d/%y").strftime("%Y-%m-%d")
								print "%s,%s,%s,%s,%s,%s"%(sha256,wallet,a.split("_-_")[0],a.split("_-_")[1],firstSeen,"-".join(mined_lastShared))							
								found=True
								break
						if found:
							break



def get_activity_period(poolData):
	firstPayment=datetime.now()
	lastActivity=datetime(1999,1,1)
	pools=[]
	for poolInfo in poolData:
		if not poolInfo['POOL'] in pools:
			pools.append(poolInfo['POOL'])
		if poolInfo['FIRST_PAYMENT'] and poolInfo['FIRST_PAYMENT']<firstPayment:
			firstPayment=poolInfo['FIRST_PAYMENT']
		if poolInfo['LAST_PAYMENT'] and poolInfo['LAST_PAYMENT']>=lastActivity:
			lastActivity=poolInfo['LAST_PAYMENT']
		if not str(poolInfo['LAST_SHARE'])=='nan' and datetime.strptime (poolInfo['LAST_SHARE'],"%Y-%m-%d")>=lastActivity:
			lastActivity=datetime.strptime (poolInfo['LAST_SHARE'],"%Y-%m-%d")
	return firstPayment,lastActivity

def get_all_payments (wallet,pool,verbose=False):
	directory='../data/infoWallets/'
	dirs=[directory+f for f in os.listdir(directory) if '201' in f and not '.' in f]	
	allPayments={}	
	for snapshot in sorted(dirs,reverse=True):
		filename='%s/pg_%s/%s_payments.pickle'%(snapshot,pool,wallet)
		first_payment=None
		last_payment=None
		if os.path.exists(filename):
			payments=pickle.load(open(filename))
			if len(payments)>0:
				for timestamp in payments:
					if payments[timestamp] is not None and payments[timestamp]>0 and not timestamp in allPayments:
						allPayments[timestamp]=payments[timestamp]
						# print snapshot,pool,timestamp,datetime.fromtimestamp(timestamp),payments[timestamp]
					elif payments[timestamp] is not None and allPayments[timestamp] != payments[timestamp]:
						if verbose: print "WARNING: different payments (%s vs %s) for same date %s"%(allPayments[timestamp],payments[timestamp],timestamp)
				break
	return allPayments

def update_info_wallet_file_usd():
	xmr2usd=pd.read_csv('../data/xmr-value.csv')
	xmr2usd['date']=pd.to_datetime(xmr2usd['date'])
	# print xmr2usd
	# return
	INFO_FILE_NO_USD='../data/infoWallets/info_wallets.csv'
	info_wallets = pd.read_csv(INFO_FILE_NO_USD,keep_default_na=False,na_values=['nan','nodata','NaN'])
	info_wallets=info_wallets.dropna(subset=['HASHES','HASHRATE','LAST_SHARE','BALANCE','TOTAL_PAID','NUM_PAYMENTS'], how='all')
	for index, row in info_wallets.iterrows():
		wallet=row['USER']
		pool=row['POOL']
		total_paid_user_this_pool=row['TOTAL_PAID']
		try:
			lastActivity=datetime.strptime (row['LAST_SHARE'],"%Y-%m-%d")
		except:
			lastActivity=datetime(1999,1,1)
		allPayments=get_all_payments(wallet,pool)
		sortedPayments=sorted(allPayments.keys(),reverse=True)
		if len(sortedPayments)>0:
			total_sum_payments_this_pool=0
			total_usd_this_pool=0
			meanExchangeRates=0.0
			totalExchangeRates=0
			for timestamp in sortedPayments:
				date=datetime.fromtimestamp(timestamp).date()
				try:
					exchangeRate=float(xmr2usd.loc[xmr2usd.date==date]['PriceUSD'])
					meanExchangeRates+=exchangeRate
					totalExchangeRates+=1
				except:
					exchangeRate=float(xmr2usd.tail(1)['PriceUSD'])
				moneroPayment=allPayments[timestamp]
				total_sum_payments_this_pool+=moneroPayment
				converted=moneroPayment*exchangeRate
				total_usd_this_pool+=converted
			delta=total_paid_user_this_pool-total_sum_payments_this_pool
			if delta>1:
				# EXCHANGE RATE IS MEAN OBTAINED FROM AVAILABLE PAYMENTS
				# meanExchangeRates=meanExchangeRates/totalExchangeRates
				# exchangeRate=meanExchangeRates

				# EXCHANGE RATE IS THE ONE FROM THE LAST PAYMENT
				lastPayment=datetime.fromtimestamp(sortedPayments[0])
				try:
					exchangeRate=float(xmr2usd.loc[xmr2usd.date==lastPayment.date()]['PriceUSD'])
				except Exception as e:
					print (e)
					print lastPayment
					exit()

				# EXCHANGE RATE IS THE ONE FROM THE LAST ACTIVITY, IF ANY. OTHERWISE IS THE OVERALL MEAN
				# if lastActivity>datetime(2014,1,1):
				# 	exchangeRate=float(xmr2usd.loc[xmr2usd.date==lastActivity.date()]['PriceUSD'])
				# else:
				# 	exchangeRate=xmr2usd['PriceUSD'].mean()
				total_usd_this_pool+=int(total_paid_user_this_pool-total_sum_payments_this_pool)*exchangeRate
			elif delta<=-1:
				print "WARNING: Changing total paid of %s in %s. %.2f for %.2f"%(wallet,pool,total_paid_user_this_pool,total_sum_payments_this_pool)
				info_wallets.at[index,'TOTAL_PAID']=total_sum_payments_this_pool
				# print "Pool %s. Payment on %s of %s XMR=%.2f USD (exchange rate=%.2f)"%(pool,date,allPayments[timestamp],converted,exchangeRate)
		else:
			# IN ABSESCENCE OF PAYMENT DATA, THE EXCHANGE RATE IS THE ONE FROM THE LAST ACTIVITY, IF ANY. OTHERWISE IS THE OVERALL MEAN
			if lastActivity>datetime(2014,1,1):
				exchangeRate=float(xmr2usd.loc[xmr2usd.date==lastActivity.date()]['PriceUSD'])
			else:
				exchangeRate=xmr2usd['PriceUSD'].mean()

			total_usd_this_pool=total_paid_user_this_pool*exchangeRate
			total_sum_payments_this_pool=total_paid_user_this_pool
		info_wallets.at[index,'USD']=total_usd_this_pool
	info_wallets.to_csv(INFO_FILE,na_rep='nan',index=False)

def total_paid_usd(wallet,totalPaidUser,numSamples,poolData,verbose=False):
	xmr2usd=pd.read_csv('../data/xmr-value2.csv')
	xmr2usd['date']=pd.to_datetime(xmr2usd['date'])
	# print xmr2usd
	# return
	directory='../data/infoWallets/'
	dirs=[directory+f for f in os.listdir(directory) if '2018' in f and not '.' in f]	
	lastSharePools=info_wallets_withData[(info_wallets_withData['USER'].str.contains(wallet))].groupby('POOL')['LAST_SHARE']
	totalMonero=0
	totalUSD=0
	totalExchangeRates=0
	totalRates=0
	fd=open('../data/payments_usd_per_pool.csv','a+')
	for pool,lastShare in lastSharePools:
		allPayments=get_all_payments(wallet,pool)
		sortedPayments=sorted(allPayments.keys(),reverse=True)
		total_paid_user_this_pool=float(info_wallets_withData[(info_wallets_withData['USER'].str.contains(w)) & info_wallets_withData['TOTAL_PAID'].notnull() & info_wallets_withData['POOL'].str.contains(pool)]['TOTAL_PAID'].agg('sum'))
		for i in range(0,len(poolData)):
			if poolData[i]['POOL']==pool:
				break		
		if len(sortedPayments)>0:
			total_sum_payments_this_pool=0
			total_usd_this_pool=0			
			for timestamp in sortedPayments:
				date=datetime.fromtimestamp(timestamp).date()
				exchangeRate=float(xmr2usd.loc[xmr2usd.date==date]['PriceUSD'])
				totalExchangeRates+=exchangeRate
				totalRates+=1
				moneroPayment=allPayments[timestamp]
				totalMonero+=moneroPayment
				total_sum_payments_this_pool+=moneroPayment
				converted=moneroPayment*exchangeRate
				total_usd_this_pool+=converted
				totalUSD+=converted
			delta=total_paid_user_this_pool-total_sum_payments_this_pool			
			if delta>1:
				lastActivity=datetime.strptime (poolData[i]['LAST_SHARE'],"%Y-%m-%d")
				if lastActivity>datetime(2014,1,1):
					exchangeRate=float(xmr2usd.loc[xmr2usd.date==lastActivity.date()]['PriceUSD'])
				else:
					exchangeRate=xmr2usd['PriceUSD'].mean()
				total_usd_this_pool+=int(total_paid_user_this_pool-total_sum_payments_this_pool)*exchangeRate
			elif delta<0:
				total_paid_this_pool=total_sum_payments_this_pool
				# print "Pool %s. Payment on %s of %s XMR=%.2f USD (exchange rate=%.2f)"%(pool,date,allPayments[timestamp],converted,exchangeRate)
		else:
			if str(poolData[i]['LAST_SHARE'])!='nan':
				lastActivity=datetime.strptime (poolData[i]['LAST_SHARE'],"%Y-%m-%d")
			else:
				lastActivity=datetime(1999,1,1)
			if lastActivity>datetime(2014,1,1):
				exchangeRate=float(xmr2usd.loc[xmr2usd.date==lastActivity.date()]['PriceUSD'])
			else:
				exchangeRate=xmr2usd['PriceUSD'].mean()
			total_usd_this_pool=total_paid_user_this_pool*exchangeRate
			total_sum_payments_this_pool=total_paid_user_this_pool
		fd.write('%s,%s,%.2f,%.2f\n'%(pool,wallet,total_sum_payments_this_pool,total_usd_this_pool))
	fd.close()
	return
	if verbose: print wallet
	# if os.path.exists('../data/stats_wallets/%s.pickle'%wallet):
	# 	totalPaidUser,numSamples,poolData=pickle.load(open('../data/stats_wallets/%s.pickle'%wallet))			
	# else:
	# 	totalPaidUser,numSamples,poolData=stats_wallet(w,verbose=False)
	
	if totalRates>0:
		averageExchangeRate=totalExchangeRates*1.0/totalRates
		delta=totalPaidUser-totalMonero
		if delta>1:
			firstPayment,lastActivity=get_activity_period(poolData)
			if lastActivity>datetime(2014,1,1):
				exchangeRate=float(xmr2usd.loc[xmr2usd.date==lastActivity.date()]['PriceUSD'])
				if verbose: print "DIFFERENT DATA. Total paid user (%.2f) greater than sum of payments (%.2f). Add difference of %s (lastActivity exchangeRate=%.2f)"%(totalPaidUser,totalMonero,int(totalPaidUser-totalMonero)*exchangeRate,exchangeRate)
				totalUSD+=int(totalPaidUser-totalMonero)*exchangeRate
			else:
				if verbose: print "DIFFERENT DATA. Total paid user (%.2f) greater than sum of payments (%.2f). Add difference of %s (average exchangeRate of payments=%.2f)"%(totalPaidUser,totalMonero,int(totalPaidUser-totalMonero)*averageExchangeRate,averageExchangeRate)
				totalUSD+=int(totalPaidUser-totalMonero)*averageExchangeRate
		elif delta<0:
			if verbose: print "DIFFERENT DATA. Sum of payments (%.2f) greater than totalPaidUser (%.2f). Updating... "%(totalMonero,totalPaidUser)
			totalPaidUser=totalMonero
		else:
			if verbose: print "Total Paid: %s XMR , %.2f USD (average exchange rate=%.2f)"%(totalMonero,totalUSD,averageExchangeRate)
	elif totalPaidUser is not None:
		firstPayment,lastActivity=get_activity_period(poolData)
		if lastActivity>datetime(2014,1,1):
			exchangeRate=float(xmr2usd.loc[xmr2usd.date==lastActivity.date()]['PriceUSD'])
			if verbose: print "NO PAYMENT DATA. LastActivity:%s ExchangeRate:%.2f. Total Paid: %.2f XMR. Total USD:%.2f"%(lastActivity,exchangeRate,totalPaidUser,totalPaidUser*exchangeRate)
			totalUSD=totalPaidUser*exchangeRate
		else:
			if verbose: print "NO PAYMENT DATA and NO LAST ACTIVITY. Using mean exchange rate (%.2f). Total Paid: %.2f XMR. Total USD:%.2f"%(xmr2usd['PriceUSD'].mean(),totalPaidUser,totalPaidUser*xmr2usd['PriceUSD'].mean())
			totalUSD=totalPaidUser*xmr2usd['PriceUSD'].mean()
	else:
		if verbose: print "NO PAYMENT DATA and Total Paid User missing. USD=0"
		totalUSD=0
	if verbose: print
	
	# totalPaidUser,numSamples,poolData=stats_wallet(w,numTab=numTab,verbose=verbose,snapshot=snapshot)
	pickle.dump((totalPaidUser,numSamples,poolData,totalUSD),open('../data/stats_wallets/%s.pickle'%wallet,'wb'))
	return totalUSD

def stats_wallet(w,numTab=0,verbose=False):
	tabs="\t"*numTab
	if (len(list(info_wallets_withData[(info_wallets_withData['USER'].str.contains(w))]['TOTAL_PAID'])))>0:
		totalPaidUser=float(info_wallets_withData[(info_wallets_withData['USER'].str.contains(w)) & info_wallets_withData['TOTAL_PAID'].notnull()]['TOTAL_PAID'].agg('sum'))
		totalUSD=float(info_wallets_withData[(info_wallets_withData['USER'].str.contains(w)) & info_wallets_withData['USD'].notnull()]['USD'].agg('sum'))
	else:
		totalPaidUser=None
		totalUSD=None

	lastSharePools=info_wallets_withData[(info_wallets_withData['USER'].str.contains(w))].groupby('POOL')['LAST_SHARE']
	lastSharePoolsString="\n"
	poolData={}
	startPayment={}
	for pool,lastShare in lastSharePools:
		poolData[pool]={'LAST_SHARE':lastShare.iloc[0]}
		lastSharePoolsString+="\t"*(numTab+1)+"%s (Last share: %s)"%(pool,lastShare.iloc[0])
		# if pool=='minexmr':
		# 	filename='../data/infoWallets/minexmr_data_20180719/%s_payments.pickle'%w
		# else:
		# filename='../data/infoWallets/%s/pg_%s/%s_payments.pickle'%(snapshot,pool,w)
		first_payment=None
		last_payment=None
		directory='../data/infoWallets/'
		files=[f for f in os.listdir(directory) if '201' in f and not '.' in f]
		payments=get_all_payments(w,pool,verbose=verbose)
		if payments is not None and len(payments)>0:
			sorted_payments=sorted(payments.items(),key=operator.itemgetter(0),reverse=False)
			first_payment=datetime.fromtimestamp(sorted_payments[0][0])
			last_payment=datetime.fromtimestamp(sorted_payments[-1][0])
		# else:
		# 	print filename,"does not exist"
		if first_payment is not None:
			poolData[pool]['FIRST_PAYMENT']=first_payment
			startPayment[pool]=first_payment
			poolData[pool]['LAST_PAYMENT']=last_payment
			lastSharePoolsString+='. Payments: from %s to %s\n'%(first_payment.strftime("%Y-%m-%d"),last_payment.strftime("%Y-%m-%d"))
		else:
			lastSharePoolsString+="\n"
			poolData[pool]['FIRST_PAYMENT']=None
			startPayment[pool]=datetime.now()
			poolData[pool]['LAST_PAYMENT']=None
	orderedPoolData=sorted(startPayment,key=lambda x:startPayment[x])
	poolDataWallet=[]
	for pool in orderedPoolData:
		#print "%s,%s,%s,%s"%(pool,poolData[pool]['FIRST_PAYMENT'],poolData[pool]['LAST_PAYMENT'],poolData[pool]['LAST_SHARE'])
		poolDataWallet.append({'POOL':pool,'FIRST_PAYMENT':poolData[pool]['FIRST_PAYMENT'],'LAST_PAYMENT':poolData[pool]['LAST_PAYMENT'],'LAST_SHARE':poolData[pool]['LAST_SHARE']})
	samples=list(set(data_from_samples[data_from_samples['USER'].notnull() & data_from_samples['USER'].str.contains(w)]['SHA256']))
	numSamples=len(samples)
	# totalUSD=total_paid_usd(w,totalPaidUser,numSamples,poolDataWallet,verbose=verbose)
	return totalPaidUser,numSamples,poolDataWallet,totalUSD
# Return the total Paid, samples observed and wallets found for a given list of wallets. If verbose, prints the results per wallet
def stats_wallets(wallets,numTab=0,verbose=False):
	tabs="\t"*numTab
	totalPaid=None
	totalSamples=0
	totalWallets=0
	poolDataWallets={}
	totalUSDWallets=0
	for w in wallets:
		present=False
		for user in list(info_wallets_withData['USER']):
			if w in user:
				present=True
		if present:
			if os.path.exists('../data/stats_wallets/%s.pickle'%w):
				totalPaidUser,numSamples,poolData,totalUSD=pickle.load(open('../data/stats_wallets/%s.pickle'%w))
			else:
				totalPaidUser,numSamples,poolData,totalUSD=stats_wallet(w,numTab=numTab,verbose=verbose)
				pickle.dump((totalPaidUser,numSamples,poolData,totalUSD),open('../data/stats_wallets/%s.pickle'%w,'wb'))
			if totalPaidUser is not None:
				if totalPaid is None:
					totalPaid=0
				poolDataWallets[w]=poolData
				totalPaid+=totalPaidUser
				totalUSDWallets+=totalUSD
				totalSamples+=numSamples
				totalWallets+=1
		else:
			if verbose: print tabs+"%s not found"%w

	if verbose: print tabs+"TOTAL:{:,.2f} XMR ({:,.2f} USD), {} samples, {} wallets".format(totalPaid,totalUSDWallets,totalSamples, totalWallets)	
	return totalPaid,totalSamples,totalWallets,poolDataWallets,totalUSDWallets

def generate_stats_wallets_all():
	wallets=[]
	for w in list(data_from_samples_with_users['USER']):
		for wallet in str(w).split(','):
			# These filters are to focus only in Monero addresses.
			if len(str(wallet))>90 and str(wallet)[0]=='4':
				if wallet.split('.')[0] in exchange_addresses and len(wallet.split('.'))>1:
					wallets.append(".".join(wallet.split('.')[:2]).split('+')[0].split('/')[0].split(":")[0].split('@')[0])	
				else:
					wallets.append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0].split('@')[0])
	wallets=list(set(wallets))		
	#wallets=list(set(list(info_wallets_withData['USER'])))
	stats_wallets(wallets,verbose=False)

def get_samples_wallet(wallet,snapshot='20180723'):
	samples=list(set(data_from_samples[data_from_samples['USER'].notnull() & data_from_samples['USER'].str.contains(w)]['SHA256']))
	return samples

# Filter those wallets that have been active in the last days, and then print the top N by hashrate or total paid
def get_recent_wallets(days=10,n=50,byHashRate=False,pool=None):
	wallets_with_lastShare= info_wallets[info_wallets['LAST_SHARE'].notnull()]
	#2018-04-02 07:04:1522648929
	wallets_with_lastShare['LAST_SHARE']=pd.to_datetime(wallets_with_lastShare['LAST_SHARE'],format="%Y-%m-%d")
	now = datetime.now()
	then = now - timedelta(days=days)
	if byHashRate:
		print wallets_with_lastShare[(wallets_with_lastShare['LAST_SHARE'] > then)][['USER','LAST_SHARE','HASHRATE']].sort_values(by=['HASHRATE'],ascending=False).head(n=n)
	else:
		print wallets_with_lastShare[(wallets_with_lastShare['LAST_SHARE'] > then)][['USER','LAST_SHARE','TOTAL_PAID']].sort_values(by=['TOTAL_PAID'],ascending=False).head(n=n)

def get_currency(wallet,emails_monero=[],emails_btc=[]):
	if len(wallet)==0 or str(wallet)=='nan':
		return "NotWallet"
	if str(wallet).startswith('Sumoo'):
		return 'SUMOKOIN'
	elif str(wallet)[0]=='4' and len(str(wallet))>90:
		return 'MONERO'
	elif str(wallet)[0]=='2' and len(str(wallet))>=96:
		return 'BYTECOIN'
	elif str(wallet).startswith('etn'):
		return 'ELECTRONEUM'
	elif str(wallet).startswith('iz') and len(wallet)>=96:
		return 'INTENSECOIN'
	elif str(wallet).startswith('C') and len(wallet)==35:
		return 'CRYPTONITE'
	elif str(wallet).lower().startswith('wm') and not '@' in wallet:
		return 'AEON'
	elif str(wallet).startswith('0x') and len(str(wallet))>40:
		return 'ETHEREUM'
	elif str(wallet).startswith('TRT'):
		return 'TURTLECOIN'
	#elif (str(wallet).lower()[0]=='t' or str(wallet).lower()[0]=='z'):
	elif (str(wallet).lower()[0]=='t' or str(wallet).lower()[0]=='z') and len(wallet)>=35 and not '@' in str(wallet[:35]):
		return 'ZCASH'
	elif (str(wallet)[0]=='1' or str(wallet)[0]=='3') and len(wallet)>=26:
		return 'BITCOIN'
	elif '@' in str(wallet):
		#for pool in emails_monero:
		#	if str(wallet) in emails_monero[pool]:
		#		return 'MONERO'
		#for pool in emails_btc:
		#	if str(wallet) in emails_btc[pool]:
		#		return 'BITCOIN'
		return 'EMAIL'
	else:
		return 'OTHER'
def analyse_wallets_per_currency(emails_monero=[],emails_btc=[]):
	wallets_currency={'EMAIL':[],'ELECTRONEUM':[],'MONERO':[],'BITCOIN':[],'ZCASH':[],'ETHEREUM':[],'TURTLECOIN':[],'AEON':[],'BYTECOIN':[],'INTENSECOIN':[],'SUMOKOIN':[],'CRYPTONITE':[],'OTHER':[]}
	for w in list(data_from_samples['USER']):
		for wallet in str(w).split(','):
			if len(wallet)==0 or str(wallet)=='nan':
				continue
			if str(wallet).startswith('Sumoo'):
				wallets_currency['SUMOKOIN'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif str(wallet)[0]=='4' and len(str(wallet))>90:
				if wallet.split('.')[0] in exchange_addresses and len(wallet.split('.'))>1:
					wallets_currency['MONERO'].append(".".join(wallet.split('.')[:2]).split('+')[0].split('/')[0].split(":")[0].split('@')[0])
				else:
					wallets_currency['MONERO'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0].split('@')[0])
			elif str(wallet)[0]=='2' and len(str(wallet))>=96:
				wallets_currency['BYTECOIN'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif str(wallet).startswith('etn'):
				wallets_currency['ELECTRONEUM'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif str(wallet).startswith('iz') and len(wallet)>=96:
				wallets_currency['INTENSECOIN'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif str(wallet).startswith('C') and len(wallet)>=35:
				wallets_currency['CRYPTONITE'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif str(wallet).lower().startswith('wm') and not '@' in wallet:
				wallets_currency['AEON'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif str(wallet).startswith('0x') and len(str(wallet))>40:
				wallets_currency['ETHEREUM'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif str(wallet).startswith('TRT'):
				wallets_currency['TURTLECOIN'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			#elif (str(wallet).lower()[0]=='t' or str(wallet).lower()[0]=='z'):
			elif (str(wallet).lower()[0]=='t' or str(wallet).lower()[0]=='z') and len(wallet)>=35 and not '@' in str(wallet[:35]):
				wallets_currency['ZCASH'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif (str(wallet)[0]=='1' or str(wallet)[0]=='3') and len(wallet)>=26:
				wallets_currency['BITCOIN'].append(wallet.split('.')[0].split('+')[0].split('/')[0].split(":")[0])
			elif '@' in str(wallet):
				# for pool in emails_monero:
				# 	if str(wallet) in emails_monero[pool]:
				# 		wallets_currency['MONERO'].append(wallet)				
				# 		break
				# for pool in emails_btc:
				# 	if str(wallet) in emails_btc[pool]:
				# 		wallets_currency['BITCOIN'].append(wallet)
				# 		break						
				wallets_currency['EMAIL'].append(wallet)
			else:
				wallets_currency['OTHER'].append(wallet)
	for currency in wallets_currency:
		wallets_currency[currency]=list(set(wallets_currency[currency]))

def get_evidence_mining(wallet,onlyPaloAlto=True):
	if onlyPaloAlto:
		# CONSIDER ONLY THOSE THAT HAVE BEEN REPORTED BY PALO-ALTO
		sources=data_from_samples.loc[data_from_samples.USER.notnull() & data_from_samples.USER.str.contains(wallet)]['SOURCE']
		inPaloAlto=False
		for s in list(sources):
			if 'PALOALTO' in s:
				inPaloAlto=True
				break
		if not inPaloAlto:
			return "NOT-FOUND",[],0


	totalSamples=len(list(data_from_samples.loc[data_from_samples.USER.notnull() & data_from_samples.USER.str.contains(wallet)]['SHA256']))	
	# TRY TO PROVIDE EVIDENCE FROM HYBRID-ANALISIS
	samples_wallet=data_from_samples.loc[data_from_samples.USER.notnull() & data_from_samples.USER.str.contains(wallet) & data_from_samples.SOURCE.str.contains('HYBRID')]
	if len(samples_wallet)>0:
		return "HYBRID-ANALYSIS",list(samples_wallet['SHA256']),totalSamples
	# IF NOT, TRY TO PROVIDE EVIDENCE FROM VIRUS-TOTAL
	samples_wallet=data_from_samples.loc[data_from_samples.USER.notnull() & data_from_samples.USER.str.contains(wallet) & (data_from_samples.SOURCE.str.contains('REPORT') | data_from_samples.SOURCE.str.contains('NETWORK') | data_from_samples.SOURCE.str.contains('BEHAVIOUR'))]
	if len(samples_wallet)>0:
		return "VIRUS-TOTAL",list(samples_wallet['SHA256']),totalSamples
	# LASTLY, PROVIDE PALO-ALTO SOURCE
	samples_wallet=data_from_samples.loc[data_from_samples.USER.notnull() & data_from_samples.USER.str.contains(wallet)]
	if len(samples_wallet)>0:
		return "PALO-ALTO",list(samples_wallet['SHA256']),totalSamples
	# SHOULD NOT REACH THIS!
	return "NOT-FOUND",[],totalSamples


def get_working_wallets(pool,days=-1):
	wallets_with_lastShare= info_wallets_withData[info_wallets_withData['LAST_SHARE'].notnull()]
	#2018-04-02 07:04:1522648929
	wallets_with_lastShare['LAST_SHARE']=pd.to_datetime(wallets_with_lastShare['LAST_SHARE'],format="%Y-%m-%d")
	now = datetime.now()
	if days>0:
		then = now - timedelta(days=days)
	else:
		# Get those active from 2018
		then=datetime(2018,1,1)
	# fd=open('../data/wallets_pools/%s_wallets_%s.csv'%(pool,then.strftime("%Y-%m-%d")),'w')		
	fd=open('../data/wallets_pools/%s_wallets.csv'%(pool),'w')		
	# samples=wallets_with_lastShare[wallets_with_lastShare['POOL'].notnull() & wallets_with_lastShare['POOL'].str.contains(pool,case=False) & (wallets_with_lastShare['LAST_SHARE'] > then)]
	samples=wallets_with_lastShare[wallets_with_lastShare['POOL'].notnull() & wallets_with_lastShare['POOL'].str.contains(pool,case=False)]
	data={}
	for i,row in samples.iterrows():
		user=row['USER']
		last_share=row['LAST_SHARE']
		
		
		total_paid_this_pool=info_wallets_withData.loc[(info_wallets_withData['USER'].notnull()) & (info_wallets_withData['USER']==user) & (info_wallets_withData['POOL'].notnull()) & (info_wallets_withData['POOL']==pool)]['TOTAL_PAID'].agg('sum')
		if math.isnan(total_paid_this_pool):
			total_paid_this_pool=0
		total_paid_all_pools=info_wallets_withData.loc[(info_wallets_withData['USER'].notnull()) & (info_wallets_withData['USER']==user)]['TOTAL_PAID'].agg('sum')
		if not user in data:
			data[user]={'LAST_SHARE':last_share,'TOTAL_PAID_THIS_POOL':total_paid_this_pool,'TOTAL_PAID_ALL_POOLS':info_wallets_withData.loc[(info_wallets_withData['USER'].notnull()) & (info_wallets_withData['USER']==user)]['TOTAL_PAID'].agg('sum')}
	ordered_data=sorted(data,key=lambda x: data[x]['TOTAL_PAID_THIS_POOL'],reverse=True)
	fd.write("WALLET,LAST_SHARE,PAID-%s,PAID-ALL,NUM-SAMPLES,SAMPLE-EVIDENCE\n"%(pool.upper()))
	for user in ordered_data:
		source,hash_list,totalSamples=get_evidence_mining(user,onlyPaloAlto=False)
		if source=="NOT-FOUND":
			continue
		elif source=='HYBRID-ANALYSIS':
			evidence='https://www.hybrid-analysis.com/search?query=+%s'%hash_list[0]
		elif source=='VIRUS-TOTAL':
			evidence='https://www.virustotal.com/en/file/%s/analysis/'%hash_list[0]
		elif source=='PALO-ALTO':
			evidence='https://github.com/pan-unit42/iocs/blob/master/cryptocurrency_miners/xmr_wallets.txt'
		last_share=data[user]['LAST_SHARE']
		total_paid_this_pool=data[user]['TOTAL_PAID_THIS_POOL']
		total_paid_all_pools=data[user]['TOTAL_PAID_ALL_POOLS']
		fd.write("%s,%s,%.2f,%.2f,%d,%s\n"%(user,last_share,total_paid_this_pool,total_paid_all_pools,totalSamples,evidence))
	fd.close()
	

		

###############################
### CALL THE FUNCTIONS HERE ###
###############################
if __name__ == "__main__":
	
	print_top_paid(latexFormat=True,withUSD=True)
